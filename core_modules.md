# Model checking and software verification
The course consists of a part on model checking followed by one on software verification. In the first part the main concepts of model checking are introduced. After demonstrating how to transitions systems can be used to model a variaty of systems, the course will showcase temporal logics (LTL, CTL, and CTL*), discuss their relative expressiveness, and present their main properties.

## Syllabus
- The modelling problem
- Transition systems as operational models
- Temporal logics
- Safety, Liveness, and Fairness

## Learning outcomes
- Ability to model systems through transitions systems
- Ability to formalise safety and liveness properties
- Ability to state fairness conditions

## Readings
- Clarke, Grumberg, Peled. *Model Checking*. MIT Press (Chapters, 1-4 & 6)
- Baier, Katoen. *Principles of Model Checking*. MIT Press (Chapters, 1-3 & 5-6)


# Formal Behavioural Specifications
The course will introduce the students to the machinery of behavioral types for the specifications and analysis of concurrent and distributed systems. The course starts with a preliminary simple type system instrumental for the introduction of the basic notions and principles of this area. In the second part of the course more powerful systems are presented together with the array of properties they guarantee. The final part of the course will survey the practical benefits of the approach with a focus on automatic code generation and monitoring of message-passing software.

## Syllabus
- Basics of behavioural types: the dyadic case
- Correctness-by-construction
- The Multi-party case
- Choreographic approaches
- Practical repercussions

## Learning outcomes
The main expected learning outcomes are:
- A critical understanding of behavioural type systems
- The ability to model message-passing software through behavioural types 
- The ability to conduct formal analysis of message-passing software
- The understanding of the relation between behavioural types and software engineering of message-passing software

## Readings
- TBA

# Modelling and Verification of Reactive Systems
The course will review the main linguistic and practical concepts underpinning parallel, concurrent, and distributed programming. After motivating the need for concurrent programming and surveying the basic problems and fundamental algorithms to tackle them, the course will give an indepth account of multithreading, non-determinism, synchronisation. Finally, the course will present models and corresponding linguistic primitives at the base of shared-memory and message-passing concurrency. 

## Syllabus
- Principles of Parallel and Concurrent Programming
- Introduction to Concurrency
- Paradigms for Parallel Programming
- Interference and Atomicity, Mutual Exclusion, Semaphores, Monitors
- Elements of Concurrent and Distributed Programming


## Learning outcomes
The main expected learning outcomes are:
- A critical understanding of the basic problems of concurrency
- The knowledge of basic algorithms for the coordination of threads
- The ability to design and reason about multi-threaded applications
- The ability to use programming primities for concurrency and distribution

## Readings
- Maurice Herlihy and Nir Shavit. *The Art of Multiprocessor Programming*. Morgan Kaufmann, 2008
- Gregory Andrews. *Multithreaded Parallel and Distributed Programming*. Addison Wesley, 2000
